/*
 *  Copyright (c) 2022-2025 Mikhail Knyazhev <markus621@yandex.com>. All rights reserved.
 *  Use of this source code is governed by a BSD 3-Clause license that can be found in the LICENSE file.
 */

package code

import (
	"bytes"
	"os"

	"go.osspkg.com/errors"
	"go.osspkg.com/ioutils/data"

	"go.osspkg.com/goppy/v2/internal/gen/ormbuilder/common"
	"go.osspkg.com/goppy/v2/internal/gen/ormbuilder/fields"
	"go.osspkg.com/goppy/v2/internal/gen/ormbuilder/tmpl"
	"go.osspkg.com/goppy/v2/internal/gen/ormbuilder/visitor"
)

type (
	modelHEAD struct {
		PkgName    string
		FileName   string
		RTag, WTag string
		Imports    []string
	}

	modelCRUD struct {
		Dialect  string
		FileName string
		Name     string
		Table    string
		PK       Field
		ColsLen  tmpl.Repeatable
		Cols     []tmpl.Escaped
		Fields   []string
		OnCreate []Auto
		OnUpdate []Auto
		RCols    []Field
		RO       bool
	}

	Field struct {
		Field string
		Col   tmpl.Escaped
		Type  string
	}

	Auto struct {
		Field string
		Func  string
	}
)

func Generate(c common.Config, v *visitor.Visitor) (err error) {
	w := data.NewBuffer(1024)
	cw := data.NewBuffer(1024)

	imports := make([]string, 0)
	for _, ik := range v.Imports.Keys() {
		if iv, ok := v.Imports.Get(ik); ok {
			imports = append(imports, "\n"+ik+` "`+iv+`"`)
		}
	}

	headers := modelHEAD{
		PkgName:  v.PkgName,
		FileName: common.SplitLast(v.FilePath, "/"),
		RTag:     c.DBRead,
		WTag:     c.DBWrite,
		Imports:  imports,
	}

	if err = tmpl.Build(w, tmplHEAD, headers); err != nil {
		return
	}

	if err = tmpl.Build(cw, tmplCOMMON, headers); err != nil {
		return
	}

	if len(v.Models) == 0 {
		return
	}

	for _, m := range v.Models {

		crud := modelCRUD{
			Dialect:  string(c.Dialect),
			FileName: common.SplitLast(v.FilePath, "/"),
			Name:     string(m.Name),
			Table:    string(m.Table),
			PK:       Field{},
		}

		for _, f := range m.Fields {
			if len(f.Col()) == 0 {
				continue
			}

			if attr, ok := m.Attr.FirstValue(fields.AttrAction); ok {
				switch attr {
				case fields.AttrValueActionRO:
					crud.RO = true
				}
			}

			switch f.(type) {
			case fields.Time, fields.JSONB:
			default:
				crud.RCols = append(crud.RCols, Field{
					Field: f.Name(),
					Col:   tmpl.Escaped(f.Col()),
					Type:  f.RawType(),
				})
			}

			if _, ok := f.Attr().Get(fields.AttrIndexPK); ok {
				crud.PK = Field{
					Field: f.Name(),
					Col:   tmpl.Escaped(f.Col()),
					Type:  f.RawType(),
				}
				if _, ok = f.Attr().Get(fields.AttrFieldAuto); !ok {
					continue
				}
			}

			if attrs, ok := f.Attr().Get(fields.AttrFieldAuto); ok {
				for _, attr := range attrs {
					if len(attr.Value) == 0 || f.Type() == fields.FieldTypeLink {
						continue
					}
					auto := Auto{Field: f.Name(), Func: attr.Value[0]}
					switch attr.Key {
					case "c":
						crud.OnCreate = append(crud.OnCreate, auto)
					case "u":
						crud.OnUpdate = append(crud.OnUpdate, auto)
					default:
						crud.OnCreate = append(crud.OnCreate, auto)
						crud.OnUpdate = append(crud.OnUpdate, auto)
					}
				}
			}

			crud.Fields = append(crud.Fields, f.Name())
			crud.Cols = append(crud.Cols, tmpl.Escaped(f.Col()))
		}

		crud.ColsLen = tmpl.Repeatable(len(crud.Cols))

		if crud.ColsLen == 0 {
			continue
		}

		if err = tmpl.Build(w, tmplCRUD, crud); err != nil {
			return
		}
	}

	bb := w.Bytes()
	bb = bytes.ReplaceAll(bb, []byte("@"), []byte("`"))

	return errors.Wrap(
		os.WriteFile(v.FilePath+"_orm.go", bb, 0755),
		os.WriteFile("common_orm.go", cw.Bytes(), 0755),
	)
}

const tmplHEAD = `// Code generated by goppy-cli for goppy.orm. DO NOT EDIT.
package {{.PkgName}}

import (
	"context"
	"go.osspkg.com/goppy/v2/orm"{{range .Imports}}{{.}}{{end}}
)

type Repo{{.FileName|title}} struct {
	orm        orm.ORM
	rtag, wtag string
}

func NewRepository{{.FileName|title}}(orm orm.ORM) *Repo{{.FileName|title}} {
	return &Repo{{.FileName|title}}{
		orm:  orm,
		rtag: "{{.RTag}}",
		wtag: "{{.WTag}}",
	}
}

func (v *Repo{{.FileName|title}}) Tag{{.RTag|title}}() orm.Stmt {
	return v.orm.Tag(v.rtag)
}

func (v *Repo{{.FileName|title}}) Tag{{.WTag|title}}() orm.Stmt {
	return v.orm.Tag(v.wtag)
}
`

const tmplCRUD = `
{{$G := .}}

{{if not .RO}}
const sql{{.Table|title}}Create{{.Name}} = @{{ queries .Dialect "INSERT INTO " (.Table|esc .Dialect) " (" .Cols ") " }}
			{{ queries .Dialect "VALUES (" .ColsLen ") " }}
			{{if .PK.Col}}{{end}}
@

func (v *Repo{{.FileName|title}}) Create{{.Name}}(ctx context.Context, ms []*{{.Name}}, opts ...CreateOption) error {
	if len(ms) == 0 {
		return nil
	}

	for _, m := range ms {
		{{range .OnCreate}}m.{{.Field}}={{.Func}};{{end}}
	}

	buf := _sqlBuilderPool.Get()
	defer func() { _sqlBuilderPool.Put(buf) }()

	buf.WriteString(sql{{.Table|title}}Create{{.Name}})
	for _, o := range opts {
		o(buf)
	}

	{{if .PK.Col}}buf.WriteString(@ {{ queries .Dialect "RETURNING (" .PK.Col ")" }}@){{end}}
	buf.WriteString(@;@)

	return v.orm.Tag(v.wtag).Tx(ctx, "{{.Table|lower}}_create", func(tx orm.Tx) {
		for _, m := range ms {
			tx.Query(func(q orm.Querier) {
				q.SQL(buf.String(),{{ fields "m." .Fields }})
				{{if .PK.Col}}q.Bind(func(bind orm.Scanner) error {
					return bind.Scan(&m.{{.PK.Field}})
				}){{end}}
			})
		}
	})
}


const sql{{.Table|title}}Update{{.Name}} = @{{ queries .Dialect "UPDATE " (.Table|esc .Dialect) " SET " }}
			{{ queries .Dialect (.Dialect|pls .Cols) }}
			{{ queries .Dialect " WHERE " .PK.Col " = " (.Cols|len|incr 1) }};
@

func (v *Repo{{.FileName|title}}) Update{{.Name}}(ctx context.Context, ms []*{{.Name}}) error {
	if len(ms) == 0 {
		return nil
	}

	for _, m := range ms {
		{{range .OnUpdate}}m.{{.Field}}={{.Func}};{{end}}
	}

	if len(ms) > 1 {
		return v.orm.Tag(v.wtag).Tx(ctx, "{{.Table|lower}}_update", func(tx orm.Tx) {
			tx.Exec(func(e orm.Executor) {
				e.SQL(sql{{.Table|title}}Update{{.Name}})
				for _, m := range ms {
					e.Params({{ fields "m." .Fields }} m.{{.PK.Field}})
				}
			})
		})
	}

	return v.orm.Tag(v.wtag).Exec(ctx, "{{.Table|lower}}_update", func(e orm.Executor) {
		e.SQL(sql{{.Table|title}}Update{{.Name}},{{ fields "ms[0]." .Fields }} ms[0].{{.PK.Field}})
	})
}

const sql{{.Table|title}}Delete{{.Name}} = @{{ queries .Dialect "DELETE FROM " (.Table|esc .Dialect) }}
			{{ queries .Dialect " WHERE " .PK.Col " = ANY(" 1 ")"}};
@

func (v *Repo{{.FileName|title}}) Delete{{.Name}}(ctx context.Context, pk []{{.PK.Type}}) error {
	if len(pk) == 0 {
		return nil
	}

	return v.orm.Tag(v.wtag).Exec(ctx, "{{.Table|lower}}_delete", func(e orm.Executor) {
		e.SQL(sql{{.Table|title}}Delete{{.Name}}, pk)
	})
}
{{end}}

const sql{{$G.Table|title}}Read{{$G.Name}}All = @{{ queries $G.Dialect "SELECT " $G.Cols }}
			{{ queries $G.Dialect " FROM " ($G.Table|esc $G.Dialect) }};
@

func (v *Repo{{$G.FileName|title}}) Read{{$G.Name}}All(ctx context.Context) ([]{{$G.Name}}, 
error) {
	result := make([]{{$G.Name}},0,2)
	err := v.orm.Tag(v.rtag).Query(ctx, "{{$G.Table|lower}}_read_all", func(q orm.Querier) {
		q.SQL(sql{{$G.Table|title}}Read{{$G.Name}}All)
		q.Bind(func(bind orm.Scanner) error {
			m := {{$G.Name}}{}
			if e := bind.Scan({{ fields "&m." $G.Fields }}); e!= nil{
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err!= nil{
		return nil, err
	}
	return result, nil
}

{{range $i, $x := .RCols}}
const sql{{$G.Table|title}}Read{{$G.Name}}By{{$x.Field}} = @{{ queries $G.Dialect "SELECT " $G.Cols }}
			{{ queries $G.Dialect " FROM " ($G.Table|esc $G.Dialect) }}
			{{ queries $G.Dialect " WHERE " $x.Col " = ANY(" 1 ")"}}
@

func (v *Repo{{$G.FileName|title}}) Read{{$G.Name}}By{{$x.Field}}(
ctx context.Context, args []{{$x.Type}}, opts ...ReadOption,
) ([]{{$G.Name}}, error) {
	if len(args) == 0 {
		return nil, nil
	}

	buf := _sqlBuilderPool.Get()
	defer func() { _sqlBuilderPool.Put(buf) }()

	buf.WriteString(sql{{$G.Table|title}}Read{{$G.Name}}By{{$x.Field}})
	for _, o := range opts {
		o(buf)
	}

	buf.WriteString(@;@)

	result := make([]{{$G.Name}},0,2)
	err := v.orm.Tag(v.rtag).Query(ctx, "{{$G.Table|lower}}_read_by_{{$x.Col}}", func(q orm.Querier) {
		q.SQL(buf.String(), args)
		q.Bind(func(bind orm.Scanner) error {
			m := {{$G.Name}}{}
			if e := bind.Scan({{ fields "&m." $G.Fields }}); e!= nil{
				return e
			}
			result = append(result, m)
			return nil
		})
	})
	if err!= nil{
		return nil, err
	}
	return result, nil
}
{{end}}


{{range $i, $x := .RCols}}
const sql{{$G.Table|title}}Count{{$G.Name}}By{{$x.Field}} = @{{ queries $G.Dialect "SELECT COUNT(*) " }}
			{{ queries $G.Dialect " FROM " ($G.Table|esc $G.Dialect) }}
			{{ queries $G.Dialect " WHERE " $x.Col " = ANY(" 1 ")"}};
@

func (v *Repo{{$G.FileName|title}}) Count{{$G.Name}}By{{$x.Field}}(
ctx context.Context, args []{{$x.Type}},
) (int64, error) {
    if len(args) == 0 {
		return 0, nil
	}

	var count int64
	err := v.orm.Tag(v.rtag).Query(ctx, "{{$G.Table|lower}}_count_by_{{$x.Col}}", func(q orm.Querier) {
		q.SQL(sql{{$G.Table|title}}Count{{$G.Name}}By{{$x.Field}}, args)
		q.Bind(func(bind orm.Scanner) error {
			return bind.Scan(&count)
		})
	})

	return count, err
}
{{end}}

`
