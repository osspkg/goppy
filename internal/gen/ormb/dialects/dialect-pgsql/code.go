/*
 *  Copyright (c) 2022-2025 Mikhail Knyazhev <markus621@yandex.com>. All rights reserved.
 *  Use of this source code is governed by a BSD 3-Clause license that can be found in the LICENSE file.
 */

package dialect_pgsql

import (
	"io"
	"slices"
	"strings"

	"go.osspkg.com/do"
	"go.osspkg.com/ioutils/data"

	"go.osspkg.com/goppy/v2/internal/gen/ormb/common"
	"go.osspkg.com/goppy/v2/internal/gen/ormb/table"
)

const sqlComma = "`"

type fieldItem struct {
	Name   string
	Col    string
	GoType string
}

type Code struct {
	E *Escape
}

func (c Code) Build(t *table.Table, ci common.CodeInfo) []byte {
	buf := data.NewBuffer(1024)

	c.header(buf, ci)

	crud := table.GetFullCRUD()
	if attr, ok := t.Attrs().GetByKey(table.AttrKeyCRUD); ok {
		crud = attr[0].Value
	}

	if slices.Contains(crud, table.AttrValueCRUDc) {
		c.creates(buf, t)
	}
	if slices.Contains(crud, table.AttrValueCRUDr) {
		c.selects(buf, t)
	}
	if slices.Contains(crud, table.AttrValueCRUDu) {
		c.updates(buf, t)
	}
	if slices.Contains(crud, table.AttrValueCRUDd) {
		c.deletes(buf, t)
	}

	return buf.Bytes()
}

func (c Code) header(w io.Writer, ci common.CodeInfo) {
	common.Writeln(w, `// Code generated by goppy-cli for goppy.orm. DO NOT EDIT.`)
	common.Writelnf(w, `package %s`, ci.PkgName)
	common.Writeln(w, `import (`)
	common.Writeln(w, `"context"`)
	common.Writeln(w, `"go.osspkg.com/goppy/v2/orm"`)
	for _, imp := range ci.Imports {
		common.Writelnf(w, `%s "%s"`, imp.Name, imp.Pkg)
	}
	common.Writeln(w, `)`)
}

func (c Code) creates(w io.Writer, t *table.Table) {
	var (
		cols   []string
		fields []string
		pk     fieldItem
	)

	for _, field := range t.Fields {
		if a, ok := field.Attrs().GetByKey(table.AttrKeyFieldCol); ok {
			col := a[0].Value[0]
			if _, ok := field.Attrs().GetByKeyDo(table.AttrKeyIndex, table.AttrDoIndexPK); ok {
				pk.Col = col
				pk.Name = field.Name()
				continue
			}
			cols = append(cols, col)
			fields = append(fields, field.Name())
		}
	}

	{

		common.Writef(w, `const sqlCreate%s=`, t.ModelName)
		common.Write(w, sqlComma)
		common.Writef(w, `INSERT INTO %s (%s) VALUES (%s)`,
			c.E.Cols(t.TableName), c.E.Cols(cols...), c.E.VarsRangeStr(1, len(cols)))
		common.Writeln(w, sqlComma)

		common.Writelnf(w, `func (v *Repo) CreateBulk%s(ctx context.Context, ms []*%s, opts ...CreateOption) error {`,
			t.ModelName, t.ModelName)
		common.Writeln(w, `if len(ms) == 0 {`)
		common.Writeln(w, `return nil`)
		common.Writeln(w, `}`)

		if _, ok := t.GetAttrsByKeyDo(table.AttrKeyFieldAuto, table.AttrValueCRUDc); ok {
			common.Writeln(w, `for _, m := range ms {`)
			for _, field := range t.Fields {
				if a, ok := field.Attrs().GetByKey(table.AttrKeyFieldAuto); ok && a[0].Do == table.AttrDoCreate {
					common.Writelnf(w, `m.%s=%s`, field.Name(), a[0].Value[0])
				}
			}
			common.Writeln(w, `}`)
		}

		common.Writeln(w, `buf := _sqlBuilderPool.Get()`)
		common.Writeln(w, `defer func() { _sqlBuilderPool.Put(buf) }()`)
		common.Writelnf(w, `buf.WriteString(sqlCreate%s)`, t.ModelName)
		common.Writeln(w, `for _, o := range opts {`)
		common.Writeln(w, `o(buf)`)
		common.Writeln(w, `}`)
		if len(pk.Col) > 0 {
			common.Writelnf(w, "buf.WriteString(` RETURNING (%s)`)", c.E.Cols(pk.Col))
		}
		common.Writeln(w, `buf.WriteString(";")`)

		common.Writelnf(w, `return v.Master().Tx(ctx, "%s_create_bulk", func(tx orm.Tx) {`, t.TableName)
		common.Writeln(w, `for _, m := range ms {`)
		common.Writeln(w, `tx.Query(func(q orm.Querier) {`)
		common.Writelnf(w, `q.SQL(buf.String(),m.%s)`, strings.Join(fields, ", m."))
		if len(pk.Col) > 0 {
			common.Writeln(w, `q.Bind(func(bind orm.Scanner) error{`)
			common.Writelnf(w, `return bind.Scan(&m.%s)`, pk.Name)
			common.Writeln(w, `})`)
		}
		common.Writeln(w, `})`)
		common.Writeln(w, `}`)
		common.Writeln(w, `})`)
		common.Writeln(w, `}`)
	}

	{
		common.Writelnf(w, `func (v *Repo) Create%s(ctx context.Context, m *%s, opts ...CreateOption) error {`,
			t.ModelName, t.ModelName)

		if _, ok := t.GetAttrsByKeyDo(table.AttrKeyFieldAuto, table.AttrValueCRUDc); ok {
			for _, field := range t.Fields {
				if a, ok := field.Attrs().GetByKey(table.AttrKeyFieldAuto); ok && a[0].Do == table.AttrDoCreate {
					common.Writelnf(w, `m.%s=%s`, field.Name(), a[0].Value[0])
				}
			}
		}

		common.Writeln(w, `buf := _sqlBuilderPool.Get()`)
		common.Writeln(w, `defer func() { _sqlBuilderPool.Put(buf) }()`)
		common.Writelnf(w, `buf.WriteString(sqlCreate%s)`, t.ModelName)
		common.Writeln(w, `for _, o := range opts {`)
		common.Writeln(w, `o(buf)`)
		common.Writeln(w, `}`)
		if len(pk.Col) > 0 {
			common.Writelnf(w, "buf.WriteString(` RETURNING (%s)`)", c.E.Cols(pk.Col))
		}
		common.Writeln(w, `buf.WriteString(";")`)

		common.Writelnf(w, `return v.Master().Query(ctx, "%s_create", func(q orm.Querier) {`, t.TableName)
		common.Writelnf(w, `q.SQL(buf.String(),m.%s)`, strings.Join(fields, ", m."))
		if len(pk.Col) > 0 {
			common.Writeln(w, `q.Bind(func(bind orm.Scanner) error{`)
			common.Writelnf(w, `return bind.Scan(&m.%s)`, pk.Name)
			common.Writeln(w, `})`)
		}
		common.Writeln(w, `})`)
		common.Writeln(w, `}`)
	}
}

func (c Code) deletes(w io.Writer, t *table.Table) {
	var (
		items []fieldItem
	)

	for _, field := range t.Fields {
		if a, ok := field.Attrs().GetByKey(table.AttrKeyFieldCol); ok {
			items = append(items, fieldItem{
				Name:   field.Name(),
				Col:    a[0].Value[0],
				GoType: field.GoType(),
			})
		}
	}

	for _, item := range items {
		common.Writef(w, `const sqlDelete%sBy%s=`, t.ModelName, item.Name)
		common.Write(w, sqlComma)
		common.Writef(w, `DELETE FROM %s WHERE %s=ANY(%s);`,
			c.E.Cols(t.TableName), c.E.Cols(item.Col), c.E.Vars(1))
		common.Writeln(w, sqlComma)

		common.Writelnf(w, `func (v *Repo) Delete%sBy%s(ctx context.Context, ms ...%s) error {`,
			t.ModelName, item.Name, item.GoType)
		common.Writeln(w, `if len(ms) == 0 {`)
		common.Writeln(w, `return nil`)
		common.Writeln(w, `}`)

		common.Writelnf(w, `return v.Master().Tx(ctx, "%s_delete_by_%s", func(tx orm.Tx) {`, t.TableName, item.Col)
		common.Writeln(w, `tx.Exec(func(e orm.Executor) {`)
		common.Writelnf(w, `e.SQL(sqlDelete%sBy%s, ms)`, t.ModelName, item.Name)
		common.Writeln(w, `})`)
		common.Writeln(w, `})`)
		common.Writeln(w, `}`)
	}
}

func (c Code) updates(w io.Writer, t *table.Table) {
	var (
		items  []fieldItem
		cols   []string
		fields []string
	)

	for _, field := range t.Fields {
		if a, ok := field.Attrs().GetByKey(table.AttrKeyFieldCol); ok {
			cols = append(cols, a[0].Value[0])
			fields = append(fields, field.Name())
			if _, ok := field.Attrs().GetByKeyDo(table.AttrKeyIndex, table.AttrDoIndexPK); ok {
				items = append(items, fieldItem{
					Name: field.Name(),
					Col:  a[0].Value[0],
				})
			}
		}
	}

	if len(items) == 0 {
		for i, col := range cols {
			items = append(items, fieldItem{
				Name: fields[i],
				Col:  col,
			})
		}
	}

	for _, item := range items {
		common.Writef(w, `const sqlUpdate%sBy%s=`, t.ModelName, item.Name)
		common.Write(w, sqlComma)
		common.Writef(w, `UPDATE %s SET %s WHERE %s=%s;`,
			c.E.Cols(t.TableName),
			strings.Join(
				do.ToSlice[string, string, string](
					do.CombineMap[string, string](
						do.Exclude(cols, item.Col),
						c.E.VarsRange(1, len(cols)-1),
					),
					func(value string, key string) string {
						return c.E.Cols(key) + "=" + value
					},
				),
				", "),
			c.E.Cols(item.Col), c.E.Vars(len(cols)))
		common.Writeln(w, sqlComma)

		common.Writelnf(w, `func (v *Repo) Update%sBy%s(ctx context.Context, ms ...*%s) error {`,
			t.ModelName, item.Name, t.ModelName)
		common.Writeln(w, `if len(ms) == 0 {`)
		common.Writeln(w, `return nil`)
		common.Writeln(w, `}`)

		if _, ok := t.GetAttrsByKeyDo(table.AttrKeyFieldAuto, table.AttrValueCRUDu); ok {
			common.Writeln(w, `for _, m := range ms {`)
			for _, field := range t.Fields {
				if a, ok := field.Attrs().GetByKey(table.AttrKeyFieldAuto); ok && a[0].Do == table.AttrDoUpdate {
					common.Writelnf(w, `m.%s=%s`, field.Name(), a[0].Value[0])
				}
			}
			common.Writeln(w, `}`)
		}

		common.Writeln(w, `if len(ms) == 1 {`)
		common.Writelnf(w, `return v.Master().Exec(ctx, "%s_update_by_%s", func(e orm.Executor) {`,
			t.TableName, item.Col)
		common.Writelnf(w, `e.SQL(sqlUpdate%sBy%s, ms[0].%s, ms[0].%s)`,
			t.ModelName, item.Name, strings.Join(do.Exclude(fields, item.Name), ", ms[0]."), item.Name)
		common.Writeln(w, `})`)
		common.Writeln(w, `}`)

		common.Writelnf(w, `return v.Master().Tx(ctx, "%s_update_bulk_by_%s", func(tx orm.Tx) {`, t.TableName, item.Col)
		common.Writeln(w, `tx.Exec(func(e orm.Executor) {`)
		common.Writelnf(w, `e.SQL(sqlUpdate%sBy%s)`, t.ModelName, item.Name)
		common.Writeln(w, `for _, m := range ms {`)
		common.Writelnf(w, `e.Params(m.%s, m.%s)`, strings.Join(do.Exclude(fields, item.Name), ", m."), item.Name)
		common.Writeln(w, `}`)
		common.Writeln(w, `})`)
		common.Writeln(w, `})`)
		common.Writeln(w, `}`)
	}
}

func (c Code) selects(w io.Writer, t *table.Table) {
	var (
		items  []fieldItem
		cols   []string
		fields []string
		pk     fieldItem
	)

	for _, field := range t.Fields {
		if a, ok := field.Attrs().GetByKey(table.AttrKeyFieldCol); ok {
			if _, ok := field.Attrs().GetByKeyDo(table.AttrKeyIndex, table.AttrDoIndexPK); ok {
				pk.Col = a[0].Value[0]
				pk.Name = field.Name()
				pk.GoType = field.GoType()
			}
			cols = append(cols, a[0].Value[0])
			fields = append(fields, field.Name())
			items = append(items, fieldItem{
				Name:   field.Name(),
				Col:    a[0].Value[0],
				GoType: field.GoType(),
			})
		}
	}

	if len(pk.Col) > 0 {
		common.Writef(w, `const sqlSelectCursor%s=`, t.ModelName)
		common.Write(w, sqlComma)
		common.Writef(w, `SELECT %s FROM %s WHERE %s>%s ORDER BY %s LIMIT %s;`,
			c.E.Cols(cols...), c.E.Cols(t.TableName), c.E.Cols(pk.Col), c.E.Vars(1), c.E.Cols(pk.Col), c.E.Vars(2))
		common.Writeln(w, sqlComma)

		common.Writelnf(w, `func (v *Repo) Select%sCursor(ctx context.Context, from %s, lim uint) ([]%s,error) {`,
			t.ModelName, pk.GoType, t.ModelName)
		common.Writelnf(w, `result := make([]%s,0,lim)`, t.ModelName)
		common.Writelnf(w, `err := v.Sync().Query(ctx, "%s_read_all", func(q orm.Querier) {`,
			t.TableName)
		common.Writelnf(w, `q.SQL(sqlSelectCursor%s, from, lim)`, t.ModelName)
		common.Writeln(w, `q.Bind(func(bind orm.Scanner) error {`)
		common.Writelnf(w, `m := %s{}`, t.ModelName)
		common.Writelnf(w, `if e := bind.Scan(&m.%s); e!= nil{`, strings.Join(fields, ", &m."))
		common.Writeln(w, `return e`)
		common.Writeln(w, `}`)
		common.Writeln(w, `result = append(result, m)`)
		common.Writeln(w, `return nil`)
		common.Writeln(w, `})`)
		common.Writeln(w, `})`)
		common.Writeln(w, `if err!= nil{`)
		common.Writeln(w, `return nil, err`)
		common.Writeln(w, `}`)
		common.Writeln(w, `return result, nil`)
		common.Writeln(w, `}`)
	}

	for _, item := range items {
		common.Writef(w, `const sqlSelect%sBy%s=`, t.ModelName, item.Name)
		common.Write(w, sqlComma)
		common.Writef(w, `SELECT %s FROM %s WHERE %s=ANY(%s);`,
			c.E.Cols(cols...), c.E.Cols(t.TableName), c.E.Cols(item.Col), c.E.Vars(1))
		common.Writeln(w, sqlComma)

		common.Writelnf(w, `func (v *Repo) Select%sBy%s(ctx context.Context, args ...%s) ([]%s,error) {`,
			t.ModelName, item.Name, item.GoType, t.ModelName)
		common.Writeln(w, `if len(args) == 0 {`)
		common.Writeln(w, `return nil, nil`)
		common.Writeln(w, `}`)
		common.Writelnf(w, `result := make([]%s,0,len(args))`, t.ModelName)
		common.Writelnf(w, `err := v.Sync().Query(ctx, "%s_read_by_%s", func(q orm.Querier) {`,
			t.TableName, item.Col)
		common.Writelnf(w, `q.SQL(sqlSelect%sBy%s, args)`, t.ModelName, item.Name)
		common.Writeln(w, `q.Bind(func(bind orm.Scanner) error {`)
		common.Writelnf(w, `m := %s{}`, t.ModelName)
		common.Writelnf(w, `if e := bind.Scan(&m.%s); e!= nil{`, strings.Join(fields, ", &m."))
		common.Writeln(w, `return e`)
		common.Writeln(w, `}`)
		common.Writeln(w, `result = append(result, m)`)
		common.Writeln(w, `return nil`)
		common.Writeln(w, `})`)
		common.Writeln(w, `})`)
		common.Writeln(w, `if err!= nil{`)
		common.Writeln(w, `return nil, err`)
		common.Writeln(w, `}`)
		common.Writeln(w, `return result, nil`)
		common.Writeln(w, `}`)
	}
}
